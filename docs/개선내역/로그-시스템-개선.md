# 로그 시스템 개선: 동적 디렉토리 설정 및 레벨 제어

## 문제 상황

초기 로그 시스템에는 다음과 같은 문제들이 있었습니다:

1. **하드코딩된 경로**: 로그 파일 저장 경로가 코드에 하드코딩되어 있음
2. **설정 미적용**: `LOG_LEVEL` 환경 변수가 실제로 적용되지 않음
3. **중앙 관리 부재**: 로그 설정이 여러 곳에 분산되어 있음

## 해결 과정

### 1단계: server 폴더 기준 경로 해석

로그 디렉토리를 `server` 폴더 기준 상대 경로로 해석하도록 구현:

```python
# server/log/__init__.py
from config.server_config import settings

log_dir = settings.LOG_DIR  # 예: "log/logs"

# server 폴더 기준으로 절대 경로 변환
server_dir = Path(__file__).resolve().parent.parent
log_directory = str(server_dir / log_dir)  # server/log/logs

# 디렉토리가 없으면 생성
os.makedirs(log_directory, exist_ok=True)
```

### 2단계: 로그 레벨 적용

`LogManager`에서 환경 변수의 로그 레벨을 실제로 적용하도록 수정:

**변경 전:**
```python
logger.setLevel(logging.DEBUG)  # 항상 DEBUG
```

**변경 후:**
```python
# server_config에서 로그 레벨 읽기
from config.server_config import settings
log_level_str = settings.LOG_LEVEL
self.log_level = getattr(logging, log_level_str.upper(), logging.INFO)

# 로거에 적용
logger.setLevel(self.log_level)
stream_handler.setLevel(self.log_level)
```

### 3단계: 싱글톤 패턴 버그 수정

`LogManager`의 싱글톤 패턴에서 발생한 버그를 수정했습니다.

**문제:**
```python
def __new__(cls, *args, **kwargs):
    cls._instance = super(LogManager, cls).__new__(cls, *args, **kwargs)
    # TypeError: object.__new__() takes exactly one argument
```

**해결:**
```python
def __new__(cls, *args, **kwargs):
    if not cls._instance:
        cls._instance = super(LogManager, cls).__new__(cls)  # args, kwargs 제거
    return cls._instance
```

`object.__new__()`는 클래스만 받으므로 `*args, **kwargs`를 전달하면 안 됩니다. 파라미터는 `__init__`에서 처리됩니다.

## 기술적 결정 사항

### 1. 로그 레벨 동작 방식

로그 레벨은 설정한 레벨 이상의 로그만 출력합니다:

- `DEBUG`: 모든 로그 출력
- `INFO`: INFO 이상 출력 (DEBUG 제외)
- `WARNING`: WARNING 이상 출력
- `ERROR`: ERROR 이상 출력
- `CRITICAL`: CRITICAL만 출력

```python
# 설정된 레벨 이상만 출력
logger.setLevel(self.log_level)
stream_handler.setLevel(self.log_level)
file_handler.setLevel(logging.DEBUG)  # 파일은 항상 모든 로그 기록
```

### 2. 디렉토리 자동 생성

설정한 로그 디렉토리가 없으면 자동으로 생성:

```python
os.makedirs(log_directory, exist_ok=True)
```

### 3. 상대 경로 해석

`server` 폴더 기준으로 상대 경로를 해석하여 유연성 제공:

```python
# LOG_DIR=log/logs → server/log/logs
# LOG_DIR=logs → server/logs
server_dir = Path(__file__).resolve().parent.parent
log_directory = str(server_dir / log_dir)
```

## 결과

### 장점

1. **유연한 경로 설정**: `.env` 파일에서 로그 저장 위치 변경 가능
2. **로그 레벨 제어**: 환경에 따라 로그 출력 레벨 조절 가능
3. **자동 디렉토리 생성**: 설정한 경로가 없어도 자동 생성
4. **중앙 관리**: 모든 로그 설정이 `server_config`에서 관리됨

### 사용 예시

```env
# 개발 환경: 모든 로그 출력, server/log/logs에 저장
ENVIRONMENT=dev
LOG_LEVEL=DEBUG
LOG_DIR=log/logs

# 프로덕션 환경: 에러만 출력, server/logs/production에 저장
ENVIRONMENT=prd
LOG_LEVEL=ERROR
LOG_DIR=logs/production
```

## 적용 범위

다음 파일들이 로그 설정을 사용합니다:

- `server/log/__init__.py`: LOG_DIR 읽기 및 디렉토리 생성
- `server/log/log_manager.py`: LOG_LEVEL 읽기 및 적용
- `server/config/server_config.py`: 환경 변수 정의

---

## 중복 로그 제거 (2025-12-20)

### 문제 상황

API 호출 시 다음과 같은 중복 로그가 발생했습니다:

1. **중복된 로그 출력**: `apiCall` 함수에서 이미 상세한 로그를 출력하는데, 각 API 파일(`UserSettingsAPI`, `ScriptAPI`, `LogAPI`)에서도 동일한 정보를 로깅
2. **로그 가독성 저하**: 동일한 정보가 여러 번 출력되어 로그가 길어지고 가독성이 떨어짐
3. **성능 영향**: 불필요한 로그 출력으로 인한 성능 저하 가능성

### 해결 과정

#### 1단계: 중복 로그 식별

`apiCall` 함수(`UI/src/js/api/api.js`)에서 이미 다음 정보를 로깅:
- 요청 시작: `[apiCall] 요청 시작: ${method} ${url}`
- 응답 받음: `[apiCall] 응답 받음: ${response.status} ${response.statusText}`
- 응답 시간: `[apiCall] 응답 시간: ${(endTime - startTime).toFixed(2)}ms`
- 응답 데이터: `[apiCall] ✅ 응답 데이터: ${data}`
- 에러 발생: `[apiCall] ❌ API 호출 실패`

각 API 파일에서도 동일한 정보를 중복 로깅하고 있었습니다.

#### 2단계: 중복 로그 제거

각 API 파일에서 중복되는 로그를 제거:

**변경 전 (`UserSettingsAPI`):**
```javascript
async getAllSettings() {
    const logger = getLogger();
    logger.log('[UserSettingsAPI] getAllSettings() 호출됨');
    
    try {
        const result = await apiCall('/api/config/user-settings');
        logger.log('[UserSettingsAPI] ✅ 모든 설정 조회 성공:', result);
        return result.data || result;
    } catch (error) {
        logger.error('[UserSettingsAPI] ❌ 설정 조회 실패:', error);
        throw error;
    }
}
```

**변경 후:**
```javascript
async getAllSettings() {
    try {
        const result = await apiCall('/api/config/user-settings');
        return result.data || result;
    } catch (error) {
        const logger = getLogger();
        logger.error('[UserSettingsAPI] ❌ 설정 조회 실패:', error);
        throw error;
    }
}
```

#### 3단계: 에러 로그 유지

에러 발생 시에만 각 API 파일에서 추가 에러 로그를 출력하도록 유지:
- API별 컨텍스트 정보 제공
- 에러 디버깅에 필요한 정보 유지

### 적용된 파일

다음 API 파일들에서 중복 로그가 제거되었습니다:

- `UI/src/js/api/user-settings-api.js`: 호출 시작/성공 로그 제거
- `UI/src/js/api/scriptapi.js`: 호출 시작/응답 받음/응답 시간 로그 제거
- `UI/src/js/api/logapi.js`: 호출 시작/응답 받음/응답 시간 로그 제거 (일부 메서드는 유지)

### 결과

#### 장점

1. **로그 가독성 향상**: 중복 로그 제거로 로그가 간결해짐
2. **성능 개선**: 불필요한 로그 출력 감소로 성능 향상
3. **일관성 유지**: 모든 API 호출 로그가 `apiCall`에서 일관되게 출력됨
4. **에러 디버깅 유지**: 에러 발생 시에는 여전히 API별 컨텍스트 정보 제공

#### 로그 출력 예시

**변경 전:**
```
[UserSettingsAPI] getSetting() 호출됨 - 키: screenshot.autoScreenshot
[apiCall] 요청 시작: GET /api/config/user-settings/screenshot.autoScreenshot
[apiCall] 응답 받음: 200 OK
[apiCall] 응답 시간: 15.23ms
[apiCall] ✅ 응답 데이터: {success: true, data: {key: "...", value: "true"}}
[UserSettingsAPI] ✅ 설정 조회 성공 - 키: screenshot.autoScreenshot, 값: true
```

**변경 후:**
```
[apiCall] 요청 시작: GET /api/config/user-settings/screenshot.autoScreenshot
[apiCall] 응답 받음: 200 OK
[apiCall] 응답 시간: 15.23ms
[apiCall] ✅ 응답 데이터: {success: true, data: {key: "...", value: "true"}}
```

### 예외 사항

일부 특수한 경우에는 로그를 유지했습니다:

- `LogAPI.checkLogsReady()`: 로그 저장 완료 확인은 중요한 상태 정보이므로 로그 유지
- `LogAPI.deleteNodeExecutionLog()`: 삭제 작업은 중요한 작업이므로 로그 유지

이러한 예외는 각 메서드의 특성과 중요도를 고려하여 결정되었습니다.

---

## 로그 저장 프로세스 최적화 (2025-12-21)

### 문제 상황

로그 저장 확인 프로세스에서 다음과 같은 문제가 있었습니다:

1. **과도한 대기 시간**: 로그 저장 확인이 최대 60초까지 대기하여 사용자 경험이 저하됨
2. **불명확한 상태 메시지**: 타임아웃 발생 시 저장 성공/실패 여부가 불명확함
3. **비효율적인 재시도 로직**: 각 시도마다 3초 타임아웃으로 전체 프로세스가 너무 오래 걸림

### 해결 과정

#### 1단계: 대기 시간 단축

로그 저장 확인 대기 시간을 60초에서 10초로 단축:

```python
# server/api/log_router.py
# 변경 전
max_wait_time = 60  # 60초 대기

# 변경 후
max_wait_time = 10  # 10초 대기
check_interval = 0.2  # 0.2초마다 확인 (더 빠른 응답)
```

#### 2단계: 재시도 로직 최적화

각 시도 타임아웃과 재시도 간격을 조정하여 전체 프로세스를 10초 내에 완료:

```python
# server/utils/log_client.py
# 변경 전
timeout=aiohttp.ClientTimeout(total=3)  # 각 시도 3초
retry_delay = 0.5  # 재시도 간격 0.5초

# 변경 후
timeout=aiohttp.ClientTimeout(total=2)  # 각 시도 2초
retry_delay = 0.3  # 재시도 간격 0.3초
```

#### 3단계: 명확한 상태 메시지

타임아웃 발생 시에도 저장 성공/실패 여부를 명확히 구분:

```python
# 로그가 저장된 경우
"로그 저장이 완료되었습니다."

# 로그가 저장되지 않은 경우
"로그 저장이 완료되지 않았습니다. (로그가 저장되지 않음)"

# 예상 상태와 일치하지 않는 경우
"로그 저장이 완료되지 않았습니다. (예상 상태와 일치하지 않음)"
```

### 적용된 파일

- `server/api/log_router.py`: 로그 저장 확인 대기 시간 및 메시지 개선
- `server/utils/log_client.py`: 재시도 로직 최적화

### 결과

#### 장점

1. **빠른 응답**: 로그 저장 확인이 10초 내에 완료되어 사용자 경험이 개선됨
2. **명확한 피드백**: 저장 성공/실패 여부가 명확하게 표시됨
3. **효율적인 재시도**: 최적화된 타임아웃과 간격으로 전체 프로세스가 빠르게 완료됨

#### 성능 개선

- **대기 시간**: 60초 → 10초 (83% 감소)
- **각 시도 타임아웃**: 3초 → 2초 (33% 감소)
- **재시도 간격**: 0.5초 → 0.3초 (40% 감소)
- **확인 간격**: 0.5초 → 0.2초 (60% 감소)

